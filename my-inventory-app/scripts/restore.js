const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const path = require('path');
const unzipper = require('unzipper');

// –ó–∞–≥—Ä—É–∂–∞–µ–º .env —Ñ–∞–π–ª
require('dotenv').config({ path: path.join(__dirname, '..', '.env') });

const execAsync = promisify(exec);

async function restoreDatabase(backupFile) {
  try {
    const dbUrl = process.env.DATABASE_URL;
    console.log('üîç DATABASE_URL:', dbUrl ? 'found' : 'not found');
    
    if (!dbUrl) {
      throw new Error('DATABASE_URL not found in environment variables');
    }

    // –ü–∞—Ä—Å–∏–º URL –ë–î
    const url = new URL(dbUrl);
    const dbName = url.pathname.slice(1);
    const dbUser = url.username;
    const dbHost = url.hostname;
    const dbPort = url.port || '5432';
    const dbPassword = url.password;

    const backupPath = path.join(process.cwd(), 'backups', backupFile);
    const tempDir = path.join(process.cwd(), 'backups', 'temp_restore');

    if (!fs.existsSync(backupPath)) {
      throw new Error(`Backup file not found: ${backupFile}`);
    }

    console.log('üîç Restoring database from:', backupFile);

    // –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
    if (!fs.existsSync(tempDir)) fs.mkdirSync(tempDir, { recursive: true });

    // –†–∞–∑–∞—Ä—Ö–∏–≤–∏—Ä—É–µ–º
    console.log('üì¶ Extracting archive...');
    await new Promise((resolve, reject) => {
      fs.createReadStream(backupPath)
        .pipe(unzipper.Extract({ path: tempDir }))
        .on('close', resolve)
        .on('error', reject);
    });

    // –ù–∞—Ö–æ–¥–∏–º SQL —Ñ–∞–π–ª
    const files = fs.readdirSync(tempDir);
    const sqlFile = files.find(f => f.endsWith('.sql'));
    
    if (!sqlFile) {
      throw new Error('SQL file not found in archive');
    }

    const sqlPath = path.join(tempDir, sqlFile);
    console.log('üìÑ Found SQL file:', sqlFile);

    // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ë–î
    const env = { ...process.env, PGPASSWORD: dbPassword };
    const restoreCommand = `psql --host=${dbHost} --port=${dbPort} --username=${dbUser} --dbname=${dbName} --file="${sqlPath}"`;

    console.log('üíª Executing:', restoreCommand);
    await execAsync(restoreCommand, { env });
    console.log('‚úÖ Database restored successfully');

    // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
    fs.unlinkSync(sqlPath);
    fs.rmdirSync(tempDir);

    console.log('üéâ Database restoration completed');

  } catch (error) {
    console.error('‚ùå Restore failed:', error);
    throw error;
  }
}

// –ó–∞–ø—É—Å–∫ –µ—Å–ª–∏ —Ñ–∞–π–ª –≤—ã–∑–≤–∞–Ω –Ω–∞–ø—Ä—è–º—É—é
if (require.main === module) {
  const backupFile = process.argv[2];
  if (!backupFile) {
    console.error('Usage: node restore.js <backup-file>');
    console.error('Available backups:');
    
    const backupDir = path.join(process.cwd(), 'backups');
    if (fs.existsSync(backupDir)) {
      const files = fs.readdirSync(backupDir).filter(f => f.endsWith('.zip'));
      files.forEach(f => console.log('  -', f));
    }
    
    process.exit(1);
  }
  restoreDatabase(backupFile).catch(console.error);
}

module.exports = { restoreDatabase };